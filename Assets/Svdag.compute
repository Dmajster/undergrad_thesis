#pragma kernel reduction

float4 input_dimensions;
RWStructuredBuffer<int> input;

float4 output_dimensions;
RWStructuredBuffer<int> output;

int position_to_index(const uint3 position, const uint3 dimensions)
{
	return position.y * dimensions.x * dimensions.z + position.z * dimensions.x + position.x;
}

int input_value(const uint3 position)
{
	return input[position_to_index(position, input_dimensions)];
}

[numthreads(8, 8, 8)]
void reduction(const uint3 output_position : SV_DispatchThreadID)
{
	// Prevent access to unreserved memory
	if (any(output_position >= output_dimensions))
	{
		return;
	}

	const uint3 input_position = output_position * 2;

	// Prevent access to unreserved memory
	if (any(input_position >= input_dimensions))
	{
		return;
	}

	// Check occupation status of the source voxels children
	const int output_value =
		input_value(input_position + int3(0, 0, 0)) &
		input_value(input_position + int3(0, 0, 1)) << 1 &
		input_value(input_position + int3(1, 0, 0)) << 2 &
		input_value(input_position + int3(1, 0, 1)) << 3 &
		input_value(input_position + int3(0, 1, 0)) << 4 &
		input_value(input_position + int3(0, 1, 1)) << 5 &
		input_value(input_position + int3(1, 1, 0)) << 6 &
		input_value(input_position + int3(1, 1, 1)) << 7;

	// If all children are occupied or empty then this branch is not interesting
	if (output_value == 0 || output_value == 255) {
		return;
	}

	output[position_to_index(output_position, output_dimensions)] = true;
}
